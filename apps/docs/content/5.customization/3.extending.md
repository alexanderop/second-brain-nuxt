# Extending the App

This guide covers how to extend Second Brain with new content types, pages, composables, and Claude Code skills.

## Adding New Content Types

Content types are the foundation of Second Brain. Adding a new type requires changes in three places.

### Step 1: Update the Schema

Edit `content.config.ts` to add your new type to the appropriate array:

```typescript
// For external content (requires authors)
const externalContentTypes = [
  'youtube',
  'podcast',
  // ... existing types
  'webinar', // Add your new type
] as const

// For personal content (no authors required)
const personalContentTypes = [
  'quote',
  'note',
  // ... existing types
  'idea', // Add your new type
] as const
```

If your type needs custom fields, add them to the schema object:

```typescript
schema: z.object({
  // ... existing fields

  // Your type-specific fields
  duration: z.number().optional(), // for webinar
  presenter: z.string().optional(),
}).passthrough().superRefine((data, ctx) => {
  // Add validation for required fields
  if (data.type === 'webinar' && data.duration === undefined) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: 'duration is required for webinar content type',
      path: ['duration'],
    })
  }
})
```

### Step 2: Update Runtime Types

Edit `app/constants/contentTypes.ts` to keep runtime arrays in sync:

```typescript
export const externalContentTypes = [
  // ... existing types
  'webinar', // Must match content.config.ts
] as const satisfies readonly ContentType[]
```

::alert{type="warning"}
The arrays in `contentTypes.ts` must exactly match those in `content.config.ts`. TypeScript's `satisfies` clause will error if they don't match the generated types.
::

### Step 3: Add the Type Icon

Edit `app/components/BaseTypeIcon.vue` to add an icon for your type:

```typescript
const iconMap = {
  // ... existing icons
  webinar: 'i-lucide-presentation',
} satisfies Record<ContentType, string>
```

Icons use the [Lucide icon set](https://lucide.dev/icons/). The `satisfies` keyword ensures TypeScript errors if any content type is missing an icon.

### Step 4: Add Graph Colors (Optional)

If you want custom colors in the knowledge graph, edit `app/utils/graphColors.ts`:

```typescript
export const typeColors: Record<ContentType, { fill: string; glow: string }> = {
  // ... existing colors
  webinar: { fill: '#8B5CF6', glow: 'rgba(139, 92, 246, 0.4)' },
}
```

### Creating Content

After adding the type, create content files with the new type:

```yaml
---
title: "Vue.js Nation 2024 Keynote"
type: webinar
authors: [evan-you]
url: https://example.com/webinar
duration: 45
presenter: "Evan You"
tags: [vue, conference]
---

Content body here...
```

---

## Adding New Pages

Nuxt uses file-based routing. Pages live in `app/pages/`.

### Static Pages

Create a file at the path you want:

```vue
<!-- app/pages/about.vue -->
<script setup lang="ts">
import { usePageTitle } from '~/composables/usePageTitle'

usePageTitle('About')
</script>

<template>
  <div>
    <h1 class="text-2xl font-semibold mb-8">About</h1>
    <p>Your content here...</p>
  </div>
</template>
```

The route will be `/about`.

### Dynamic Pages

Use square brackets for dynamic segments:

```vue
<!-- app/pages/topics/[topic].vue -->
<script setup lang="ts">
import { useRoute } from '#imports'
import { usePageTitle } from '~/composables/usePageTitle'
import { queryCollection } from '#imports'

const route = useRoute()
const topic = computed(() => route.params.topic as string)

usePageTitle(topic.value)

const { data: notes } = await useAsyncData(
  `topic-${topic.value}`,
  () => queryCollection('content')
    .where('tags', 'contains', topic.value)
    .all()
)
</script>

<template>
  <div>
    <h1 class="text-2xl font-semibold mb-8">
      {{ topic }}
    </h1>
    <!-- Render notes -->
  </div>
</template>
```

### Catch-All Routes

Use `[...slug].vue` for catch-all routes. The main content page uses this pattern:

```vue
<!-- app/pages/[...slug].vue -->
<script setup lang="ts">
const route = useRoute()
const slug = computed(() => {
  const params = route.params.slug
  return Array.isArray(params) ? params.join('/') : params
})
</script>
```

### Adding to Navigation

After creating a page, add it to navigation in `site.config.ts`:

```typescript
export const siteConfig = {
  nav: [
    // ... existing items
    { label: 'Topics', to: '/topics', icon: 'i-lucide-hash' },
  ],
}
```

---

## Creating Custom Composables

Composables encapsulate reusable reactive logic. They live in `app/composables/`.

### Basic Pattern

```typescript
// app/composables/useBookmarks.ts
import { useLocalStorage } from '@vueuse/core'

export function useBookmarks() {
  const bookmarks = useLocalStorage<string[]>('sb-bookmarks', [])

  function addBookmark(slug: string) {
    if (!bookmarks.value.includes(slug)) {
      bookmarks.value.push(slug)
    }
  }

  function removeBookmark(slug: string) {
    bookmarks.value = bookmarks.value.filter(b => b !== slug)
  }

  function isBookmarked(slug: string) {
    return computed(() => bookmarks.value.includes(slug))
  }

  return {
    bookmarks,
    addBookmark,
    removeBookmark,
    isBookmarked,
  }
}
```

### Data Fetching Pattern

For API-based composables:

```typescript
// app/composables/useRelatedNotes.ts
import { computed } from 'vue'
import { useAsyncData } from '#imports'

interface RelatedNote {
  slug: string
  title: string
  score: number
}

export function useRelatedNotes(slug: string) {
  const { data, status } = useAsyncData<RelatedNote[]>(
    `related-${slug}`,
    () => $fetch<RelatedNote[]>(`/api/related/${slug}`),
    { default: () => [] }
  )

  return {
    relatedNotes: data,
    isLoading: computed(() => status.value === 'pending'),
    hasRelated: computed(() => data.value.length > 0),
  }
}
```

### Shared State Pattern

For state shared across components:

```typescript
// app/composables/useShortcutsModal.ts
export function useShortcutsModal() {
  // useState ensures the state is shared across all uses
  const isOpen = useState('shortcuts-modal-open', () => false)

  return {
    isOpen,
    open: () => isOpen.value = true,
    close: () => isOpen.value = false,
    toggle: () => isOpen.value = !isOpen.value,
  }
}
```

### Best Practices

1. **Prefix with `use`**: All composables should start with `use` (e.g., `useBookmarks`)
2. **Return reactive refs**: Return `ref`, `computed`, or `readonly` values
3. **Use VueUse**: Leverage [@vueuse/core](https://vueuse.org/) for common utilities
4. **Type everything**: Define interfaces for data structures
5. **Handle loading states**: Return status for async operations

---

## Adding Claude Code Skills

Skills extend Claude Code with project-specific capabilities. They live in `.claude/skills/`.

### Skill Structure

```
.claude/skills/
└── my-skill/
    ├── SKILL.md          # Main skill definition
    └── references/       # Optional reference files
        └── template.md
```

### Creating a Skill

Create a new skill file:

```markdown
---
name: my-skill
description: Brief description of what this skill does. Use when asked to "trigger phrase" or "another trigger".
allowed-tools: Read, Write, Glob, Grep, WebFetch, AskUserQuestion
---

# My Skill

Description of the skill's purpose.

## Workflow

1. **Phase 1: Gather Information**
   - Read relevant files
   - Search for patterns

2. **Phase 2: Process**
   - Apply transformations
   - Generate output

3. **Phase 3: Save** (BLOCKING GATE)
   - Present results to user
   - Get approval before saving

## Examples

### Example 1: Basic Usage
User: "Run my-skill on X"
Steps:
1. Find X files
2. Process them
3. Output results
```

### Frontmatter Fields

| Field | Required | Description |
|-------|----------|-------------|
| `name` | Yes | Skill identifier (kebab-case) |
| `description` | Yes | What the skill does and trigger phrases |
| `allowed-tools` | Yes | Tools the skill can use |

### Common Tool Combinations

| Use Case | Tools |
|----------|-------|
| Read-only analysis | `Read, Glob, Grep` |
| Content modification | `Read, Write, Edit, Glob, Grep` |
| Web research | `Read, Write, WebFetch, WebSearch` |
| Interactive workflow | `Read, Write, AskUserQuestion, Glob` |

### Workflow Best Practices

1. **Use BLOCKING GATEs**: Always require user approval before destructive changes
2. **Parallel research**: Use `Task` tool for parallel web searches
3. **Reference other skills**: Load writing-style for content generation
4. **Phased workflows**: Break complex tasks into numbered phases
5. **Clear examples**: Show exact inputs and expected outputs

### Example: Content Validation Skill

```markdown
---
name: validate-content
description: Validate content files for quality issues. Use when asked to "check notes", "validate content", or "audit notes".
allowed-tools: Read, Glob, Grep, AskUserQuestion
---

# Content Validation Skill

Check content files for common issues.

## Checks

1. **Missing summaries**: Notes without `summary` field
2. **Orphan links**: `[[links]]` pointing to non-existent notes
3. **Empty tags**: Notes with no tags
4. **Missing authors**: External content without authors

## Workflow

### Phase 1: Scan Content

```bash
Glob: content/*.md
```

For each file:
1. Read frontmatter
2. Check required fields
3. Validate wiki-links

### Phase 2: Report Issues

Present findings:
- Critical: Broken links, missing required fields
- Warning: Missing optional fields
- Info: Suggestions for improvement

### Phase 3: Fix (Optional)

If user requests fixes:
1. Show proposed changes
2. Get approval via `AskUserQuestion`
3. Apply fixes
```

### Registering Skills

Skills are automatically discovered by Claude Code. The skill name in frontmatter should match the folder name. Users invoke skills with:

```
/my-skill
```

Or Claude may invoke them automatically based on the description's trigger phrases.

---

## Adding Server API Routes

Server routes live in `server/api/`. They're automatically available at `/api/*`.

### Basic Route

```typescript
// server/api/my-endpoint.ts
export default defineEventHandler(async (event) => {
  return {
    message: 'Hello from the API',
  }
})
```

### With Parameters

```typescript
// server/api/notes/[slug].ts
export default defineEventHandler(async (event) => {
  const slug = getRouterParam(event, 'slug')

  // Fetch note data
  const note = await queryCollection('content')
    .where('stem', '=', slug)
    .first()

  if (!note) {
    throw createError({
      statusCode: 404,
      message: `Note not found: ${slug}`,
    })
  }

  return note
})
```

### With Caching

```typescript
// server/api/stats.ts
export default defineCachedEventHandler(
  async (event) => {
    // Expensive computation here
    return computeStats()
  },
  {
    maxAge: 60 * 10, // Cache for 10 minutes
    staleMaxAge: 60 * 60, // Serve stale for 1 hour while revalidating
  }
)
```

---

## Tips for Extending

1. **Follow existing patterns**: Look at similar code in the codebase
2. **Use TypeScript**: All new code should be typed
3. **Run quality checks**: Always run `pnpm lint:fix && pnpm typecheck` before committing
4. **Test locally**: Use `pnpm dev` to test changes
5. **Keep it simple**: Avoid over-engineering—extend only what you need
