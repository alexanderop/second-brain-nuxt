<!DOCTYPE html>
<html lang="en" style="color-scheme:dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Walkthrough — Nuxt Content System</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            wt: {
              bg: '#000000', surface: '#0a0a0a', raised: '#141414',
              border: '#2a2a2a', fg: '#ffffff', muted: '#a0a0a0',
              accent: '#a855f7', file: '#c084fc', red: '#ef4444',
            },
            node: {
              component: '#a855f7', composable: '#7c3aed', utility: '#6d28d9',
              external: '#525252', event: '#d8b4fe', data: '#9333ea',
            },
          },
        },
      },
    };
  </script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
  <style>
    body { margin: 0; background: #000000; color: #ffffff; font-family: system-ui, -apple-system, sans-serif; }
    .mermaid-wrap svg { max-width: none !important; height: auto !important; }
    .mermaid-wrap .node { cursor: pointer; }
    .mermaid-wrap .node:hover rect,
    .mermaid-wrap .node:hover polygon,
    .mermaid-wrap .node:hover circle,
    .mermaid-wrap .node:hover .label-container {
      filter: brightness(1.3); transition: filter .15s;
    }
    .dt-body p { color:#a0a0a0; font-size:.88rem; line-height:1.65; margin-bottom:10px; }
    .dt-body p code {
      background:rgba(168,85,247,.12); padding:1px 6px; border-radius:4px;
      font-family:'SF Mono','Fira Code',monospace; font-size:.82rem; color:#c084fc;
    }
    .dt-body .shiki {
      background: #000000 !important;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      padding: 14px 16px;
      overflow-x: auto;
      margin: 8px 0 14px;
    }
    .dt-body .shiki code {
      font-family: 'SF Mono','Fira Code',monospace;
      font-size: .78rem;
      line-height: 1.55;
      background: none;
      padding: 0;
      border-radius: 0;
      color: inherit;
    }
    .dt-body pre.code-fallback {
      background: #000000;
      border: 1px solid #2a2a2a;
      border-radius: 8px;
      padding: 14px 16px;
      overflow-x: auto;
      margin: 8px 0 14px;
    }
    .dt-body pre.code-fallback code {
      font-family: 'SF Mono','Fira Code',monospace;
      font-size: .78rem;
      line-height: 1.55;
      color: #e0e0e0;
      background: none;
      padding: 0;
      border-radius: 0;
    }
  </style>
</head>
<body class="bg-wt-bg">
  <div id="root"></div>

  <script type="module">
    import { createHighlighter } from 'https://cdn.jsdelivr.net/npm/shiki@3.22.0/+esm'

    const { useState, useEffect, useRef, useCallback } = React;
    const h = React.createElement;

    const SUMMARY = "Markdown files with YAML frontmatter live in a flat content/ directory. Nuxt Content parses them into a SQLite database, where pages and server APIs query them via queryCollection(). Wiki-links between notes are transformed before parsing, then resolved at render time by a custom ProseA component that checks if targets exist and shows hover previews.";

    const DIAGRAM = `graph TD
      subgraph schema_layer["Schema & Configuration"]
        contentConfig["Content Config"]
        contentTypes["Content Type Taxonomy"]
        wikiTransform["Wiki-Link Transform"]
      end

      subgraph storage_layer["Storage & Parsing"]
        markdownFiles["Markdown Files"]
        sqliteDb["SQLite Database"]
      end

      subgraph query_layer["Querying & Display"]
        catchAllRoute["Catch-All Route"]
        listingPages["Listing Pages"]
        contentList["Content List"]
      end

      subgraph linking_layer["Linking & Discovery"]
        proseA["Wiki-Link Renderer"]
        backlinksApi["Backlinks API"]
        searchModal["Search Modal"]
      end

      markdownFiles -->|"validated by"| contentConfig
      contentConfig -->|"defines types via"| contentTypes
      markdownFiles -->|"transformed by"| wikiTransform
      wikiTransform -->|"parsed into"| sqliteDb
      markdownFiles -->|"parsed into"| sqliteDb
      sqliteDb -->|"queried by"| catchAllRoute
      sqliteDb -->|"filtered by"| listingPages
      listingPages -->|"renders via"| contentList
      sqliteDb -->|"resolves links via"| proseA
      sqliteDb -->|"scanned by"| backlinksApi
      sqliteDb -->|"searched via"| searchModal
      catchAllRoute -.->|"shows"| proseA
      catchAllRoute -.->|"shows"| backlinksApi

      classDef component fill:#a855f7,stroke:#c084fc,color:#fff
      classDef composable fill:#7c3aed,stroke:#a78bfa,color:#fff
      classDef utility fill:#6d28d9,stroke:#8b5cf6,color:#fff
      classDef external fill:#525252,stroke:#737373,color:#fff
      classDef event fill:#d8b4fe,stroke:#e9d5ff,color:#000
      classDef data fill:#9333ea,stroke:#a855f7,color:#fff

      class contentConfig utility
      class contentTypes utility
      class wikiTransform utility
      class markdownFiles data
      class sqliteDb external
      class catchAllRoute component
      class listingPages component
      class contentList component
      class proseA component
      class backlinksApi composable
      class searchModal component

      click contentConfig nodeClickHandler "View details"
      click contentTypes nodeClickHandler "View details"
      click wikiTransform nodeClickHandler "View details"
      click markdownFiles nodeClickHandler "View details"
      click sqliteDb nodeClickHandler "View details"
      click catchAllRoute nodeClickHandler "View details"
      click listingPages nodeClickHandler "View details"
      click contentList nodeClickHandler "View details"
      click proseA nodeClickHandler "View details"
      click backlinksApi nodeClickHandler "View details"
      click searchModal nodeClickHandler "View details"
    `;

    const NODES = {
      contentConfig: {
        title: "Content Config",
        description: "Defines all collection schemas using Zod in content.config.ts. This is the single source of truth for content structure — Nuxt Content generates TypeScript types from these schemas. Uses .passthrough() for flexibility and superRefine for business rules like 'external content requires authors'.",
        files: ["content.config.ts"],
        code: `schema: z.object({
  title: z.string(),
  type: contentTypesSchema,
  tags: z.array(z.string()).default([]),
}).passthrough().superRefine(/* validation */)`,
        lang: "typescript",
      },
      contentTypes: {
        title: "Content Type Taxonomy",
        description: "Content is split into external types (youtube, podcast, article, book — require authors) and personal types (note, evergreen, quote, map — authors optional). This classification drives validation rules and UI organization across the app.",
        files: ["content.config.ts:3-30", "app/constants/contentTypes.ts"],
      },
      wikiTransform: {
        title: "Wiki-Link Transform",
        description: "A beforeParse hook in nuxt.config.ts that converts [[slug]] wiki-link syntax into standard markdown links before Nuxt Content parses the file. This is what enables Zettelkasten-style cross-linking between notes in a flat directory.",
        files: ["nuxt.config.ts:52-59"],
        code: `hooks: {
  'content:file:beforeParse'(ctx) {
    ctx.file.body = transformWikiLinks(ctx.file.body)
  }
}`,
        lang: "typescript",
      },
      markdownFiles: {
        title: "Markdown Files",
        description: "All content lives in a flat content/ directory — organization by type happens via the frontmatter 'type' field, not folder structure. Separate subdirectories exist only for supporting collections: authors/, podcasts/, newsletters/, tweets/.",
        files: ["content/*.md"],
        code: `---
title: "Atomic Habits"
type: book
authors: [james-clear]
tags: [habits, productivity]
readingStatus: finished
---`,
        lang: "yaml",
      },
      sqliteDb: {
        title: "SQLite Database",
        description: "Nuxt Content v3 parses all markdown into an in-memory SQLite database at build time. Both server routes and client components query this same database using the queryCollection() API, which supports select, where, order, and path filtering.",
        files: ["nuxt.config.ts:106-149"],
      },
      catchAllRoute: {
        title: "Catch-All Route",
        description: "The [...slug].vue page renders any individual content item by matching the URL path against the SQLite database. It handles rich content types with specialized sections for podcasts, books, and GitHub repos, and displays backlinks and a local knowledge graph.",
        files: ["app/pages/[...slug].vue"],
        code: `const { data: page } = await useAsyncData(
  \`page-\${route.path}\`,
  () => queryCollection('content').path(route.path).first()
)`,
        lang: "typescript",
      },
      listingPages: {
        title: "Listing Pages",
        description: "Type-specific pages like books.vue, podcasts/, and tags/ filter content using queryCollection with where clauses. Each uses a pattern like .where('type', '=', 'book') for type filtering or .where('tags', 'LIKE', '%tag%') for tag filtering.",
        files: ["app/pages/books.vue", "app/pages/tags/[tag].vue", "app/pages/podcasts/index.vue"],
      },
      contentList: {
        title: "Content List",
        description: "Reusable component that receives an array of content items and renders them as cards. It enriches items with related collection data — for example, fetching podcast metadata for episodes by querying the podcasts collection.",
        files: ["app/components/ContentList.vue", "app/components/ContentCard.vue"],
      },
      proseA: {
        title: "Wiki-Link Renderer",
        description: "Custom ProseA component that replaces default anchor tags in rendered markdown. It detects wiki-links by CSS class, queries SQLite to check if the target note exists, and shows a hover popover with preview metadata. Broken links get special styling.",
        files: ["app/components/content/ProseA.vue"],
        code: `const isWikiLink = computed(() => props.class?.includes('wiki-link'))
const linkData = await useAsyncData(
  \`wiki-link-\${slug.value}\`,
  () => queryCollection('content').where('stem', '=', slug.value).first()
)`,
        lang: "typescript",
      },
      backlinksApi: {
        title: "Backlinks API",
        description: "Server route that queries all content, walks each item's markdown AST using a minimark parser to extract internal links, then builds a reverse index mapping each slug to all items that link to it. Powers the backlinks section on every note page.",
        files: ["server/api/backlinks.get.ts", "server/utils/backlinks.ts", "server/utils/minimark.ts"],
      },
      searchModal: {
        title: "Search Modal",
        description: "Command palette search that combines Fuse.js keyword matching with semantic vector search using pre-generated embeddings. Queries SQLite for searchable content sections, builds a Fuse index, merges keyword and semantic results with hybrid scoring.",
        files: ["app/components/AppSearchModal.vue", "app/composables/useContentFuse.ts"],
      },
    };

    const LEGEND = [
      { label: "Component", color: "bg-node-component" },
      { label: "Composable / API", color: "bg-node-composable" },
      { label: "Utility / Config", color: "bg-node-utility" },
      { label: "External / Infra", color: "bg-node-external" },
      { label: "Data", color: "bg-node-data" },
    ];

    // Shiki initialization
    const langs = [...new Set(Object.values(NODES).map(n => n.lang).filter(Boolean))];
    if (langs.length === 0) langs.push('typescript');

    let highlighter = null;
    try {
      highlighter = await createHighlighter({ themes: ['vitesse-dark'], langs });
    } catch (e) {
      console.warn('Shiki failed to load:', e);
    }

    const HIGHLIGHTED = {};
    for (const [id, node] of Object.entries(NODES)) {
      if (node.code && highlighter) {
        try {
          HIGHLIGHTED[id] = highlighter.codeToHtml(node.code, {
            lang: node.lang || 'typescript',
            theme: 'vitesse-dark',
          });
        } catch (e) { console.warn(`Highlight failed for ${id}:`, e); }
      }
    }

    // --- React Components ---

    function usePanZoom() {
      const viewportRef = useRef(null);
      const canvasRef = useRef(null);
      const zoomDisplayRef = useRef(null);
      const st = useRef({ zoom: 1, panX: 0, panY: 0 });
      const drag = useRef({ on: false, lx: 0, ly: 0 });

      const apply = useCallback(() => {
        const { zoom, panX, panY } = st.current;
        if (canvasRef.current)
          canvasRef.current.style.transform = `translate(${panX}px,${panY}px) scale(${zoom})`;
        if (zoomDisplayRef.current)
          zoomDisplayRef.current.textContent = Math.round(zoom * 100) + '%';
      }, []);

      const fitToScreen = useCallback(() => {
        const svg = canvasRef.current?.querySelector('svg');
        const vp = viewportRef.current;
        if (!svg || !vp) return;
        const s = st.current;
        const vw = vp.clientWidth, vh = vp.clientHeight;
        const sw = svg.getBoundingClientRect().width / s.zoom;
        const sh = svg.getBoundingClientRect().height / s.zoom;
        const fit = Math.max(0.15, Math.min(2, Math.min((vw - 80) / sw, (vh - 80) / sh)));
        s.zoom = fit;
        s.panX = (vw - sw * fit) / 2;
        s.panY = (vh - sh * fit) / 2;
        apply();
      }, [apply]);

      useEffect(() => {
        const vp = viewportRef.current;
        if (!vp) return;

        const onWheel = (e) => {
          e.preventDefault();
          const r = vp.getBoundingClientRect();
          const mx = e.clientX - r.left, my = e.clientY - r.top;
          const s = st.current;
          const f = e.deltaY < 0 ? 1.12 : 1 / 1.12;
          const nz = Math.min(4, Math.max(0.15, s.zoom * f));
          const sc = nz / s.zoom;
          s.panX = mx - sc * (mx - s.panX);
          s.panY = my - sc * (my - s.panY);
          s.zoom = nz;
          apply();
        };

        const onDown = (e) => {
          if (e.target.closest('.node')) return;
          drag.current = { on: true, lx: e.clientX, ly: e.clientY };
          vp.setPointerCapture(e.pointerId);
        };
        const onMove = (e) => {
          const d = drag.current;
          if (!d.on) return;
          st.current.panX += e.clientX - d.lx;
          st.current.panY += e.clientY - d.ly;
          d.lx = e.clientX; d.ly = e.clientY;
          apply();
        };
        const onUp = () => { drag.current.on = false; };

        vp.addEventListener('wheel', onWheel, { passive: false });
        vp.addEventListener('pointerdown', onDown);
        vp.addEventListener('pointermove', onMove);
        vp.addEventListener('pointerup', onUp);
        vp.addEventListener('pointercancel', onUp);
        window.addEventListener('resize', fitToScreen);

        return () => {
          vp.removeEventListener('wheel', onWheel);
          vp.removeEventListener('pointerdown', onDown);
          vp.removeEventListener('pointermove', onMove);
          vp.removeEventListener('pointerup', onUp);
          vp.removeEventListener('pointercancel', onUp);
          window.removeEventListener('resize', fitToScreen);
        };
      }, [apply, fitToScreen]);

      const zoomIn = useCallback(() => { st.current.zoom = Math.min(4, st.current.zoom * 1.25); apply(); }, [apply]);
      const zoomOut = useCallback(() => { st.current.zoom = Math.max(0.15, st.current.zoom / 1.25); apply(); }, [apply]);

      return { viewportRef, canvasRef, zoomDisplayRef, zoomIn, zoomOut, fitToScreen };
    }

    function MermaidDiagram({ onNodeClick }) {
      const ref = useRef(null);

      useEffect(() => {
        window.nodeClickHandler = onNodeClick;
        mermaid.initialize({
          startOnLoad: false,
          theme: 'dark',
          themeVariables: {
            primaryColor: '#0a0a0a',
            primaryTextColor: '#ffffff',
            primaryBorderColor: '#2a2a2a',
            lineColor: '#a0a0a0',
            secondaryColor: '#000000',
            tertiaryColor: '#000000',
            background: '#000000',
            mainBkg: '#0a0a0a',
            nodeBorder: '#2a2a2a',
            clusterBkg: 'rgba(10,10,10,0.8)',
            clusterBorder: '#7c3aed',
            titleColor: '#ffffff',
            edgeLabelBackground: 'transparent',
          },
          flowchart: { useMaxWidth: false, htmlLabels: true, curve: 'basis' },
          securityLevel: 'loose',
        });
        mermaid.render('walkthrough-diagram', DIAGRAM).then(({ svg, bindFunctions }) => {
          if (ref.current) {
            ref.current.innerHTML = svg;
            bindFunctions?.(ref.current);
          }
        });
        return () => { delete window.nodeClickHandler; };
      }, [onNodeClick]);

      return h('div', { ref, className: 'mermaid-wrap' });
    }

    function Summary() {
      return h('div', {
        className: 'fixed top-16 left-6 z-10 max-w-lg px-4 py-3 bg-wt-surface/80 backdrop-blur border border-wt-border rounded-lg shadow-lg pointer-events-none'
      },
        h('p', { className: 'text-sm text-wt-muted leading-relaxed' }, SUMMARY)
      );
    }

    function DetailPanel({ nodeId, node, onClose }) {
      useEffect(() => {
        const onKey = (e) => { if (e.key === 'Escape') onClose(); };
        document.addEventListener('keydown', onKey);
        return () => document.removeEventListener('keydown', onKey);
      }, [onClose]);

      const codeHtml = HIGHLIGHTED[nodeId];

      return h('div', {
        className: 'fixed top-4 right-4 bottom-4 w-[560px] z-30 bg-wt-surface border border-wt-border rounded-xl shadow-2xl flex flex-col overflow-hidden'
      },
        h('button', {
          onClick: onClose,
          className: 'absolute top-3 right-3 z-10 w-7 h-7 rounded-md border border-wt-border bg-wt-raised text-wt-muted flex items-center justify-center text-lg hover:bg-wt-red hover:border-wt-red hover:text-white transition-colors'
        }, '\u00d7'),
        h('div', { className: 'flex-1 overflow-y-auto p-5' },
          h('h2', { className: 'text-lg font-bold text-wt-fg mb-3 pr-9' }, node.title),
          h('div', { className: 'dt-body' },
            h('p', null, node.description)
          ),
          node.code ? h('div', { className: 'dt-body' },
            codeHtml
              ? h('div', { dangerouslySetInnerHTML: { __html: codeHtml } })
              : h('pre', { className: 'code-fallback' }, h('code', null, node.code))
          ) : null,
          node.files && node.files.length > 0 ? h('div', { className: 'mt-4 pt-3 border-t border-wt-border' },
            h('div', { className: 'text-[0.7rem] uppercase tracking-wider text-wt-muted font-semibold mb-1.5' }, 'Files'),
            h('code', { className: 'text-sm text-wt-file font-mono leading-relaxed' },
              node.files.map((f, i) => h('span', { key: i }, f, h('br')))
            )
          ) : null
        )
      );
    }

    function ZoomControls({ zoomDisplayRef, onZoomIn, onZoomOut, onFit }) {
      return h('div', {
        className: 'fixed bottom-5 left-5 z-20 flex flex-col gap-1.5'
      },
        h('button', {
          onClick: onZoomIn,
          className: 'w-8 h-8 bg-wt-surface border border-wt-border rounded-md text-wt-muted hover:text-wt-fg hover:bg-wt-raised transition-colors flex items-center justify-center text-lg'
        }, '+'),
        h('div', {
          ref: zoomDisplayRef,
          className: 'text-center text-xs text-wt-muted tabular-nums'
        }, '100%'),
        h('button', {
          onClick: onZoomOut,
          className: 'w-8 h-8 bg-wt-surface border border-wt-border rounded-md text-wt-muted hover:text-wt-fg hover:bg-wt-raised transition-colors flex items-center justify-center text-lg'
        }, '\u2212'),
        h('button', {
          onClick: onFit,
          className: 'w-8 h-8 mt-1 bg-wt-surface border border-wt-border rounded-md text-wt-muted hover:text-wt-fg hover:bg-wt-raised transition-colors flex items-center justify-center text-xs'
        }, 'Fit')
      );
    }

    function App() {
      const [activeId, _setActiveId] = useState(null);
      const pz = usePanZoom();

      const setActiveNode = useCallback((nodeId) => {
        _setActiveId(nodeId);
        document.querySelectorAll('.mermaid-wrap .node').forEach(n => { n.style.opacity = nodeId ? '0.4' : '1'; });
        if (nodeId) {
          const el = document.querySelector(`.mermaid-wrap .node[id*="${nodeId}"]`);
          if (el) el.style.opacity = '1';
        }
      }, []);

      const closeDetail = useCallback(() => {
        _setActiveId(null);
        document.querySelectorAll('.mermaid-wrap .node').forEach(n => { n.style.opacity = '1'; });
      }, []);

      useEffect(() => { setTimeout(pz.fitToScreen, 600); }, [pz.fitToScreen]);

      return h(React.Fragment, null,
        h('header', {
          className: 'fixed top-0 inset-x-0 z-10 px-6 py-3.5 bg-gradient-to-b from-wt-bg to-transparent pointer-events-none'
        },
          h('h1', { className: 'text-base font-semibold text-wt-fg' }, 'Nuxt Content System'),
          h('p', { className: 'text-sm text-wt-muted mt-0.5' }, 'How markdown becomes a queryable knowledge base with wiki-links')
        ),

        h(Summary),

        h('div', {
          ref: pz.viewportRef,
          className: 'w-full h-screen overflow-hidden cursor-grab active:cursor-grabbing'
        },
          h('div', {
            ref: pz.canvasRef,
            className: 'origin-top-left will-change-transform inline-block p-[80px_60px_60px]'
          },
            h(MermaidDiagram, { onNodeClick: setActiveNode })
          )
        ),

        h(ZoomControls, {
          zoomDisplayRef: pz.zoomDisplayRef,
          onZoomIn: pz.zoomIn,
          onZoomOut: pz.zoomOut,
          onFit: pz.fitToScreen
        }),

        h('div', {
          className: 'fixed bottom-5 left-1/2 -translate-x-1/2 z-20 flex gap-4 px-4 py-2 bg-wt-surface border border-wt-border rounded-lg shadow-xl'
        },
          LEGEND.map(l =>
            h('span', { key: l.label, className: 'flex items-center gap-1.5 text-xs text-wt-muted' },
              h('span', { className: `w-2 h-2 rounded-full ${l.color}` }),
              l.label
            )
          )
        ),

        activeId && NODES[activeId] ? h(DetailPanel, {
          nodeId: activeId,
          node: NODES[activeId],
          onClose: closeDetail
        }) : null,

        h('div', {
          className: 'fixed bottom-5 right-5 z-20 text-xs text-wt-muted opacity-50'
        },
          h('kbd', null, 'Scroll'), ' zoom \u00b7 ',
          h('kbd', null, 'Drag'), ' pan \u00b7 Click nodes'
        )
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(h(App));
  </script>
</body>
</html>
